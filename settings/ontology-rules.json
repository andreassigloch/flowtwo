{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "id": "graphengine-ontology-rules",
  "version": "3.1.1",
  "commit": "3ce1c19",
  "description": "Consolidated ontology: node/edge types, validation rules, decision trees, optimization goals. Single source of truth for LLM context and self-learning reward calculation.",

  "meta": {
    "sources": [
      "docs/System Decomposition Rules.md",
      "docs/AGENTEN-BASIERTES SYSTEMS ENGINEERING.md",
      "docs/ontology_schema.json"
    ],
    "standards": ["INCOSE SE Handbook v5", "INCOSE GtWR v4", "ISO/IEC/IEEE 15288:2023", "ISO/IEC/IEEE 29148:2018", "A-SPICE", "SysML 2.0"],
    "created": "2025-11-27",
    "updated": "2025-12-01",
    "author": "andreas@siglochconsulting"
  },

  "nodeTypes": {
    "SYS": {
      "name": "System",
      "description": "Top-level system boundary. Root of all decomposition.",
      "abbreviation": "SY",
      "color": "#FF00FF",
      "ansiColor": "35",
      "requiredProperties": ["uuid", "type", "name", "descr"],
      "propertyConstraints": {
        "name": { "type": "string", "maxLength": 25, "pattern": "^[A-Z][a-zA-Z0-9]*$" },
        "descr": { "type": "string" }
      },
      "allowedOutgoingEdges": ["compose"],
      "allowedTargets": { "compose": ["UC", "MOD", "FUNC", "SYS"] },
      "notes": "SYS→SYS only for external/purchased subsystems. Use FUNC→FUNC for logical decomposition."
    },
    "UC": {
      "name": "Use Case",
      "description": "User-facing functionality. Außensicht: was wird gefordert.",
      "abbreviation": "UC",
      "color": "#FFFF00",
      "ansiColor": "33",
      "requiredProperties": ["uuid", "type", "name", "descr"],
      "propertyConstraints": {
        "name": { "type": "string", "maxLength": 25, "pattern": "^[A-Z][a-zA-Z0-9]*$" },
        "descr": { "type": "string" }
      },
      "allowedOutgoingEdges": ["compose", "satisfy"],
      "allowedTargets": { "compose": ["UC", "FCHAIN"], "satisfy": ["REQ"] }
    },
    "REQ": {
      "name": "Requirement",
      "description": "Functional or non-functional requirement.",
      "abbreviation": "RQ",
      "color": "#FF0000",
      "ansiColor": "31",
      "requiredProperties": ["uuid", "type", "name", "descr"],
      "propertyConstraints": {
        "name": { "type": "string", "maxLength": 25, "pattern": "^[A-Z][a-zA-Z0-9]*$" },
        "descr": { "type": "string" }
      },
      "allowedOutgoingEdges": ["satisfy", "verify"],
      "allowedTargets": { "satisfy": ["REQ"], "verify": ["TEST"] }
    },
    "FUNC": {
      "name": "Function",
      "description": "Specific capability or processing step. Innensicht: Verhalten, Transformation.",
      "abbreviation": "FN",
      "color": "#00FF00",
      "ansiColor": "32",
      "requiredProperties": ["uuid", "type", "name", "descr"],
      "optionalProperties": {
        "volatility": {
          "type": "enum",
          "values": ["low", "medium", "high"],
          "default": "medium",
          "description": "Expected rate of change. HIGH = external APIs, AI models, integrations. LOW = core logic, persistence, stable algorithms."
        }
      },
      "propertyConstraints": {
        "name": { "type": "string", "maxLength": 25, "pattern": "^[A-Z][a-zA-Z0-9]*$" },
        "descr": { "type": "string" },
        "volatility": { "type": "enum", "values": ["low", "medium", "high"] }
      },
      "allowedOutgoingEdges": ["compose", "satisfy", "io"],
      "allowedTargets": { "compose": ["FUNC"], "satisfy": ["REQ"], "io": ["FLOW"] }
    },
    "FCHAIN": {
      "name": "Function Chain",
      "description": "Sequence of functions implementing a use case. Activity diagram.",
      "abbreviation": "FC",
      "color": "#00FFFF",
      "ansiColor": "36",
      "requiredProperties": ["uuid", "type", "name", "descr"],
      "propertyConstraints": {
        "name": { "type": "string", "maxLength": 25, "pattern": "^[A-Z][a-zA-Z0-9]*$" },
        "descr": { "type": "string" }
      },
      "allowedOutgoingEdges": ["compose"],
      "allowedTargets": { "compose": ["ACTOR", "FUNC", "FLOW"] }
    },
    "FLOW": {
      "name": "Data Flow",
      "description": "3-Layer interface: Layer 1 (Semantik) in descr, Layer 2 (Datenformat) via relation to SCHEMA, Layer 3 (Protokoll) via relation to SCHEMA.",
      "abbreviation": "FL",
      "color": "#808080",
      "ansiColor": "90",
      "requiredProperties": ["uuid", "type", "name", "descr"],
      "propertyConstraints": {
        "name": { "type": "string", "maxLength": 25, "pattern": "^[A-Z][a-zA-Z0-9]*$" },
        "descr": { "type": "string" }
      },
      "allowedOutgoingEdges": ["io", "relation"],
      "allowedTargets": { "io": ["FUNC", "ACTOR"], "relation": ["SCHEMA"] },
      "requiredRelations": ["relation→SCHEMA (DataSchema)"],
      "optionalRelations": ["relation→SCHEMA (ProtocolSchema)"]
    },
    "ACTOR": {
      "name": "Actor",
      "description": "External entity. Alles außerhalb deiner Spezifikationshoheit.",
      "abbreviation": "AC",
      "color": "#FFFF00",
      "ansiColor": "33",
      "requiredProperties": ["uuid", "type", "name", "descr"],
      "propertyConstraints": {
        "name": { "type": "string", "maxLength": 25, "pattern": "^[A-Z][a-zA-Z0-9]*$" },
        "descr": { "type": "string" }
      },
      "allowedOutgoingEdges": ["io"],
      "allowedTargets": { "io": ["FLOW"] },
      "subtypes": ["SisterSystem", "ExternalSystem", "HumanActor"]
    },
    "MOD": {
      "name": "Module",
      "description": "Physical or software component. Physische Realisierung.",
      "abbreviation": "MD",
      "color": "#0000FF",
      "ansiColor": "34",
      "requiredProperties": ["uuid", "type", "name", "descr"],
      "propertyConstraints": {
        "name": { "type": "string", "maxLength": 25, "pattern": "^[A-Z][a-zA-Z0-9]*$" },
        "descr": { "type": "string" }
      },
      "allowedOutgoingEdges": ["compose", "allocate"],
      "allowedTargets": { "compose": ["MOD"], "allocate": ["FUNC"] }
    },
    "TEST": {
      "name": "Test Case",
      "description": "Verification test case.",
      "abbreviation": "TC",
      "color": "#00FF00",
      "ansiColor": "32",
      "requiredProperties": ["uuid", "type", "name", "descr"],
      "propertyConstraints": {
        "name": { "type": "string", "maxLength": 25, "pattern": "^[A-Z][a-zA-Z0-9]*$" },
        "descr": { "type": "string" }
      },
      "allowedOutgoingEdges": ["verify"],
      "allowedTargets": { "verify": ["TEST"] }
    },
    "SCHEMA": {
      "name": "Schema",
      "description": "Global definition. Categories: DataSchema, ProtocolSchema, TypeSchema.",
      "abbreviation": "SC",
      "color": "#FFFFFF",
      "ansiColor": "37",
      "requiredProperties": ["uuid", "type", "name", "descr", "struct"],
      "propertyConstraints": {
        "name": { "type": "string", "maxLength": 25, "pattern": "^[A-Z][a-zA-Z0-9]*$" },
        "descr": { "type": "string" },
        "struct": { "type": "string", "format": "json" }
      },
      "allowedOutgoingEdges": ["relation"],
      "allowedTargets": { "relation": ["FUNC", "FLOW"] },
      "categories": {
        "DataSchema": "Data structure/format (SysML Interface Block)",
        "ProtocolSchema": "Transport behavior (SysML Flow Specification)",
        "TypeSchema": "Shared type definitions (SysML Value Type)"
      }
    }
  },

  "edgeTypes": {
    "compose": {
      "name": "Composition",
      "description": "Hierarchical parent-child nesting",
      "isNesting": true,
      "visualStyle": "implicit",
      "validConnections": [
        { "source": "SYS", "target": "SYS" },
        { "source": "SYS", "target": "UC" },
        { "source": "SYS", "target": "MOD" },
        { "source": "SYS", "target": "FUNC" },
        { "source": "UC", "target": "UC" },
        { "source": "UC", "target": "FCHAIN" },
        { "source": "FCHAIN", "target": "ACTOR" },
        { "source": "FCHAIN", "target": "FUNC" },
        { "source": "FCHAIN", "target": "FLOW" },
        { "source": "MOD", "target": "MOD" },
        { "source": "FUNC", "target": "FUNC" }
      ]
    },
    "io": {
      "name": "Data Flow",
      "description": "Input/Output connection via FLOW nodes",
      "isNesting": false,
      "isChain": true,
      "visualStyle": "solid-arrow",
      "validConnections": [
        { "source": "FUNC", "target": "FLOW" },
        { "source": "FLOW", "target": "FUNC" },
        { "source": "ACTOR", "target": "FLOW" },
        { "source": "FLOW", "target": "ACTOR" }
      ]
    },
    "satisfy": {
      "name": "Satisfaction",
      "description": "Requirement satisfaction traceability",
      "isNesting": true,
      "visualStyle": "dashed-arrow",
      "validConnections": [
        { "source": "SYS", "target": "REQ" },
        { "source": "REQ", "target": "REQ" },
        { "source": "UC", "target": "REQ" },
        { "source": "FUNC", "target": "REQ" }
      ]
    },
    "verify": {
      "name": "Verification",
      "description": "Test verification of requirements",
      "isNesting": false,
      "visualStyle": "dashed-arrow",
      "validConnections": [
        { "source": "TEST", "target": "TEST" },
        { "source": "REQ", "target": "TEST" }
      ]
    },
    "allocate": {
      "name": "Allocation",
      "description": "Function allocation to module",
      "isNesting": true,
      "visualStyle": "solid-arrow-diamond",
      "validConnections": [
        { "source": "MOD", "target": "FUNC" }
      ]
    },
    "relation": {
      "name": "Relation",
      "description": "Generic relationship (FLOW→SCHEMA for interface contracts)",
      "isNesting": false,
      "visualStyle": "gray-line",
      "validConnections": [
        { "source": "FLOW", "target": "SCHEMA" },
        { "source": "SCHEMA", "target": "FUNC" },
        { "source": "*", "target": "*" }
      ]
    }
  },

  "zoomLevels": ["L0", "L1", "L2", "L3", "L4"],
  "nestingEdgeTypes": ["compose", "satisfy", "allocate"],

  "phases": {
    "phase1_requirements": {
      "name": "System Requirements",
      "description": "Stakeholder Needs → SYS, UC, REQ nodes",
      "deliverables": ["SYS node", "UC hierarchy", "REQ nodes with satisfy edges"],
      "gateRules": ["req_semantic_id", "uc_satisfy_req", "sys_satisfy_nfr"]
    },
    "phase2_logical": {
      "name": "Logical Architecture",
      "description": "Top-Level FUNC blocks, FLOW interfaces, FCHAIN activity diagrams",
      "deliverables": ["5-9 top-level FUNC", "FLOW with SCHEMA", "FCHAIN per leaf UC"],
      "gateRules": ["millers_law", "function_requirements", "function_io", "flow_connectivity", "fchain_actor_boundary"]
    },
    "phase3_physical": {
      "name": "Physical Architecture",
      "description": "MOD hierarchy, function allocation",
      "deliverables": ["5-9 top-level MOD", "MOD→FUNC allocation"],
      "gateRules": ["millers_law", "function_allocation", "no_orphan_mod"]
    },
    "phase4_verification": {
      "name": "Integration & Verification",
      "description": "TEST nodes, full traceability",
      "deliverables": ["TEST per REQ", "Full traceability path"],
      "gateRules": ["requirements_verification", "isolation", "naming", "full_traceability"]
    }
  },

  "integrityRules": {
    "no_duplicate_nodes": {
      "id": "no_duplicate_nodes",
      "description": "No nodes with identical (type, name, parent)",
      "phase": "all",
      "severity": "error",
      "type": "hard",
      "cypher": "MATCH (p)-[e1:EDGE]->(n1), (p)-[e2:EDGE]->(n2) WHERE e1.type = 'compose' AND e2.type = 'compose' AND n1.type = n2.type AND n1.name = n2.name AND n1.semanticId < n2.semanticId RETURN n1.semanticId + ' / ' + n2.semanticId AS violation, 'Duplicate node in same parent' AS reason"
    },
    "no_duplicate_edges": {
      "id": "no_duplicate_edges",
      "description": "No edges with identical (source, target, edgeType)",
      "phase": "all",
      "severity": "error",
      "type": "hard",
      "cypher": "MATCH (a)-[r1:EDGE]->(b), (a)-[r2:EDGE]->(b) WHERE r1.type = r2.type AND r1.uuid < r2.uuid RETURN a.semanticId + ' -[' + r1.type + ']-> ' + b.semanticId AS violation, 'Duplicate edge' AS reason"
    },
    "naming": {
      "id": "naming",
      "description": "All names PascalCase, max 25 characters",
      "phase": "all",
      "severity": "error",
      "type": "hard",
      "cypher": "MATCH (n:Node) WHERE n.name IS NOT NULL AND (NOT n.name =~ '^[A-Z][a-zA-Z0-9]{0,24}$') RETURN n.semanticId AS violation, 'Invalid name format' AS reason"
    },
    "required_properties": {
      "id": "required_properties",
      "description": "All nodes must have uuid, type, name (non-empty), descr (non-empty)",
      "phase": "all",
      "severity": "error",
      "type": "hard",
      "cypher": "MATCH (n:Node) WHERE n.uuid IS NULL OR n.type IS NULL OR n.name IS NULL OR n.name = '' OR n.descr IS NULL OR n.descr = '' RETURN coalesce(n.semanticId, n.name, 'unknown') AS violation, 'Missing or empty required properties' AS reason"
    },
    "no_self_loops": {
      "id": "no_self_loops",
      "description": "No self-referencing edges (source = target)",
      "phase": "all",
      "severity": "error",
      "type": "hard",
      "cypher": "MATCH (n)-[e:EDGE]->(n) RETURN e.uuid AS violation, 'Self-referencing edge' AS reason"
    }
  },

  "validationRules": {
    "isolation": {
      "id": "isolation",
      "description": "All nodes must have at least one edge",
      "phase": "phase4_verification",
      "severity": "warning",
      "weight": 0.05,
      "cypher": "MATCH (n:Node) WHERE NOT (n)--() RETURN n.semanticId AS violation, 'Orphan node' AS reason"
    },
    "millers_law": {
      "id": "millers_law",
      "description": "5-9 children per parent node (Miller's Law applies universally to all nesting)",
      "phase": "all",
      "severity": "warning",
      "weight": 0.10,
      "cypher": "MATCH (parent)-[e:EDGE]->(child) WHERE e.type IN ['compose', 'allocate'] WITH parent, count(child) AS child_count WHERE child_count < 5 OR child_count > 9 RETURN parent.semanticId AS violation, parent.type + ' has ' + child_count + ' children (should be 5-9)' AS reason",
      "appliesTo": ["SYS→FUNC", "SYS→MOD", "FUNC→FUNC", "MOD→MOD", "UC→UC", "MOD→FUNC (allocate)"],
      "rationale": "Cognitive load principle: humans can manage 7±2 items effectively"
    },
    "function_requirements": {
      "id": "function_requirements",
      "description": "Every FUNC must satisfy at least one REQ",
      "phase": "phase2_logical",
      "severity": "error",
      "weight": 0.20,
      "cypher": "MATCH (f:Node {type: 'FUNC'}) WHERE NOT EXISTS { MATCH (f)-[e:EDGE]->(r:Node {type: 'REQ'}) WHERE e.type = 'satisfy' } RETURN f.semanticId AS violation, 'Missing satisfy→REQ edge' AS reason"
    },
    "function_io": {
      "id": "function_io",
      "description": "Every FUNC must have io input AND output via FLOW",
      "phase": "phase2_logical",
      "severity": "error",
      "weight": 0.15,
      "cypher": "MATCH (f:Node {type: 'FUNC'}) WHERE NOT EXISTS { MATCH (fl:Node {type: 'FLOW'})-[e:EDGE {type: 'io'}]->(f) } OR NOT EXISTS { MATCH (f)-[e:EDGE {type: 'io'}]->(fl:Node {type: 'FLOW'}) } RETURN f.semanticId AS violation, 'Missing io input or output' AS reason"
    },
    "flow_connectivity": {
      "id": "flow_connectivity",
      "description": "Every FLOW must have io incoming AND outgoing",
      "phase": "phase2_logical",
      "severity": "error",
      "weight": 0.15,
      "cypher": "MATCH (fl:Node {type: 'FLOW'}) WHERE NOT EXISTS { MATCH ()-[e:EDGE {type: 'io'}]->(fl) } OR NOT EXISTS { MATCH (fl)-[e:EDGE {type: 'io'}]->() } RETURN fl.semanticId AS violation, 'Disconnected FLOW' AS reason"
    },
    "fchain_actor_boundary": {
      "id": "fchain_actor_boundary",
      "description": "Every FCHAIN must have ACTOR→...→ACTOR path (at least 2 actors)",
      "phase": "phase2_logical",
      "severity": "warning",
      "weight": 0.10,
      "cypher": "MATCH (fc:Node {type: 'FCHAIN'})-[e:EDGE {type: 'compose'}]->(a:Node {type: 'ACTOR'}) WITH fc, collect(a) AS actors WHERE size(actors) < 2 RETURN fc.semanticId AS violation, 'Missing actor boundary' AS reason"
    },
    "function_allocation": {
      "id": "function_allocation",
      "description": "Every FUNC must be allocated to exactly one MOD",
      "phase": "phase3_physical",
      "severity": "error",
      "weight": 0.15,
      "cypher": "MATCH (f:Node {type: 'FUNC'}) WHERE NOT EXISTS { MATCH (m:Node {type: 'MOD'})-[e:EDGE {type: 'allocate'}]->(f) } RETURN f.semanticId AS violation, 'Unallocated function' AS reason"
    },
    "requirements_verification": {
      "id": "requirements_verification",
      "description": "Every REQ must be verified by at least one TEST",
      "phase": "phase4_verification",
      "severity": "error",
      "weight": 0.10,
      "cypher": "MATCH (r:Node {type: 'REQ'}) WHERE NOT EXISTS { MATCH (r)-[e:EDGE {type: 'verify'}]->(t:Node {type: 'TEST'}) } RETURN r.semanticId AS violation, 'Unverified requirement' AS reason"
    },
    "flow_data_schema": {
      "id": "flow_data_schema",
      "description": "Every FLOW must have relation to Data SCHEMA (Layer 2)",
      "phase": "phase2_logical",
      "severity": "warning",
      "weight": 0.05,
      "cypher": "MATCH (fl:Node {type: 'FLOW'}) WHERE NOT EXISTS { MATCH (fl)-[e:EDGE {type: 'relation'}]->(s:Node {type: 'SCHEMA'}) } RETURN fl.semanticId AS violation, 'Missing SCHEMA relation' AS reason"
    },
    "schema_struct_property": {
      "id": "schema_struct_property",
      "description": "Every SCHEMA must have struct property with JSON",
      "phase": "all",
      "severity": "error",
      "weight": 0.05,
      "cypher": "MATCH (s:Node {type: 'SCHEMA'}) WHERE s.struct IS NULL OR s.struct = '' RETURN s.semanticId AS violation, 'Missing struct property' AS reason"
    },
    "uc_satisfy_req": {
      "id": "uc_satisfy_req",
      "description": "Every functional REQ should have UC→satisfy→REQ",
      "phase": "phase1_requirements",
      "severity": "warning",
      "weight": 0.05,
      "cypher": "MATCH (r:Node {type: 'REQ'}) WHERE NOT EXISTS { MATCH (uc:Node {type: 'UC'})-[e:EDGE {type: 'satisfy'}]->(r) } AND NOT EXISTS { MATCH (sys:Node {type: 'SYS'})-[e:EDGE {type: 'satisfy'}]->(r) } RETURN r.semanticId AS violation, 'REQ not linked to UC or SYS' AS reason"
    },
    "nested_func_isolation": {
      "id": "nested_func_isolation",
      "description": "Nested FUNCs may ONLY connect to: (1) other nested FUNCs within same parent (whitebox), (2) parent-level FLOWs (IN/OUT of top-level FUNC). Direct connections between nested FUNCs of different whiteboxes are FORBIDDEN.",
      "phase": "phase2_logical",
      "severity": "error",
      "weight": 0.15,
      "type": "hard",
      "cypher": "MATCH (parent1:Node {type: 'FUNC'})-[c1:EDGE {type: 'compose'}]->(nested1:Node {type: 'FUNC'})-[io1:EDGE {type: 'io'}]->(fl:Node {type: 'FLOW'})-[io2:EDGE {type: 'io'}]->(nested2:Node {type: 'FUNC'})<-[c2:EDGE {type: 'compose'}]-(parent2:Node {type: 'FUNC'}) WHERE parent1 <> parent2 RETURN nested1.semanticId + ' → ' + nested2.semanticId AS violation, 'Cross-whitebox connection between nested functions' AS reason",
      "allowedPatterns": [
        "NestedFunc -io-> InternalFlow -io-> NestedFunc (same parent)",
        "NestedFunc -io-> ParentLevelFlow (exposed at parent boundary)"
      ],
      "forbiddenPatterns": [
        "NestedFunc(ParentA) -io-> Flow -io-> NestedFunc(ParentB)"
      ]
    },
    "volatile_func_isolation": {
      "id": "volatile_func_isolation",
      "description": "High-volatility FUNC should have low fan-in (≤2 dependents) to isolate change impact. Wrap behind adapter/facade.",
      "phase": "phase2_logical",
      "severity": "warning",
      "weight": 0.10,
      "cypher": "MATCH (f:Node {type: 'FUNC', volatility: 'high'})<-[e1:EDGE {type: 'io'}]-(fl:Node {type: 'FLOW'})<-[e2:EDGE {type: 'io'}]-(dependent:Node {type: 'FUNC'}) WITH f, count(DISTINCT dependent) as fanIn WHERE fanIn > 2 RETURN f.semanticId AS violation, 'High-volatility FUNC has ' + fanIn + ' dependents (should be ≤2). Isolate behind adapter/facade.' AS reason",
      "rationale": "Design for Change: High-volatility functions (external APIs, AI models, integrations) should be isolated to minimize ripple effects when they change.",
      "architecturalGuidance": "Wrap high-volatility FUNC behind stable interface (Adapter/Facade pattern)"
    },
    "func_description_quality": {
      "id": "func_description_quality",
      "description": "FUNC description should contain Action + Input + Output pattern",
      "phase": "phase2_logical",
      "severity": "warning",
      "weight": 0.05,
      "pattern": "[Verb] [Input-Objekt] und [liefert/gibt zurück] [Output-Objekt]",
      "cypher": "MATCH (f:Node {type: 'FUNC'}) WHERE f.descr IS NOT NULL AND NOT (f.descr =~ '.*(und|and).*(gibt|liefert|returns|produces).*') RETURN f.semanticId AS violation, 'Description should describe Action + Input + Output' AS reason"
    },
    "func_near_duplicate": {
      "id": "func_near_duplicate",
      "description": "No FUNC pairs with similarity >= 0.85 (near-duplicates)",
      "phase": "phase2_logical",
      "severity": "error",
      "type": "hard",
      "weight": 0.15,
      "threshold": 0.85,
      "note": "Requires semantic similarity calculation - not pure Cypher"
    },
    "func_merge_candidate": {
      "id": "func_merge_candidate",
      "description": "Flag FUNC pairs with similarity >= 0.70 as merge candidates",
      "phase": "phase2_logical",
      "severity": "warning",
      "weight": 0.10,
      "threshold": 0.70,
      "note": "Requires semantic similarity calculation - not pure Cypher"
    },
    "schema_near_duplicate": {
      "id": "schema_near_duplicate",
      "description": "No SCHEMA pairs with similarity >= 0.85 (near-duplicates)",
      "phase": "phase2_logical",
      "severity": "error",
      "type": "hard",
      "weight": 0.10,
      "threshold": 0.85,
      "note": "Requires Struct JSON similarity calculation - not pure Cypher"
    },
    "schema_merge_candidate": {
      "id": "schema_merge_candidate",
      "description": "Flag SCHEMA pairs with similarity >= 0.70 as merge candidates",
      "phase": "phase2_logical",
      "severity": "warning",
      "weight": 0.05,
      "threshold": 0.70,
      "note": "Requires Struct JSON similarity calculation - not pure Cypher"
    }
  },

  "funcSimilarity": {
    "description": "FUNC similarity detection for merge/abstraction candidates",
    "criteria": {
      "descriptionSemantic": {
        "weight": 0.35,
        "description": "Semantic similarity of description texts"
      },
      "actionVerb": {
        "weight": 0.25,
        "description": "Same function core from name (Validate, Create, Transform, ...)"
      },
      "flowStructure": {
        "weight": 0.25,
        "description": "Isomorphic io topology (same in/out count, similar SCHEMA types)"
      },
      "reqOverlap": {
        "weight": 0.10,
        "description": "Jaccard index on satisfy→REQ edges"
      },
      "hierarchyPosition": {
        "weight": 0.05,
        "description": "Same depth in compose tree"
      }
    },
    "thresholds": {
      "nearDuplicate": 0.85,
      "mergeCandidate": 0.70,
      "review": 0.50
    },
    "canonicalVerbs": {
      "Validate": ["Check", "Verify", "Ensure", "Assert", "Prüfen", "Validieren"],
      "Create": ["Generate", "Build", "Produce", "Make", "Erstellen", "Erzeugen"],
      "Transform": ["Convert", "Map", "Translate", "Parse", "Transformieren", "Konvertieren"],
      "Send": ["Emit", "Publish", "Dispatch", "Notify", "Senden", "Versenden"],
      "Receive": ["Accept", "Consume", "Listen", "Subscribe", "Empfangen"],
      "Store": ["Save", "Persist", "Write", "Cache", "Speichern"],
      "Retrieve": ["Load", "Fetch", "Read", "Get", "Laden", "Abrufen"],
      "Calculate": ["Compute", "Evaluate", "Derive", "Berechnen"]
    },
    "schemaAbstraction": {
      "EntitySchema": ["OrderSchema", "PaymentSchema", "ShipmentSchema", "CustomerSchema"],
      "StatusSchema": ["OrderStatus", "PaymentStatus", "ShipmentStatus"],
      "ResultSchema": ["ValidationResult", "CalculationResult", "ProcessResult"]
    }
  },

  "schemaSimilarity": {
    "description": "SCHEMA similarity detection for merge/consolidation candidates",
    "criteria": {
      "structSimilarity": {
        "weight": 0.50,
        "description": "JSON structure similarity (field names, types, nesting depth)"
      },
      "nameSimilarity": {
        "weight": 0.25,
        "description": "Name similarity (OrderSchema vs PaymentSchema)"
      },
      "usagePattern": {
        "weight": 0.25,
        "description": "Similar FLOW connections (same FUNCs use them)"
      }
    },
    "thresholds": {
      "nearDuplicate": 0.85,
      "mergeCandidate": 0.70,
      "review": 0.50
    },
    "mergeGuidance": {
      "identicalStruct": "Merge into single SCHEMA, update all FLOW relations",
      "similarStruct": "Create abstract base SCHEMA, derive specific variants",
      "differentCategory": "Keep separate (DataSchema vs ProtocolSchema)"
    }
  },

  "qualityIndicators": {
    "fanOut": {
      "description": "Outgoing edges per node",
      "threshold": 7,
      "source": "McConnell, Code Complete (2004)",
      "cypher": "MATCH (n)-[r]->() WITH n, count(r) AS fanOut WHERE fanOut > 7 RETURN n.semanticId, fanOut"
    },
    "instability": {
      "description": "I = Fan-out / (Fan-in + Fan-out), closer to 0 = more stable",
      "thresholdMax": 0.5,
      "source": "Fenton & Melton",
      "formula": "I = Fan-out / (Fan-in + Fan-out)"
    },
    "allocationCohesion": {
      "description": "Ratio of FUNC allocated to single MOD vs cross-cutting",
      "thresholdMin": 0.8,
      "source": "INCOSE SE Handbook"
    },
    "lcom4": {
      "description": "Lack of Cohesion of Methods (graph-based)",
      "thresholdOptimal": 1,
      "source": "Chidamber & Kemerer (1994)",
      "meaning": "LCOM4=1 bedeutet eine Verantwortlichkeit"
    },
    "cyclomaticComplexity": {
      "description": "Control flow complexity",
      "threshold": 10,
      "source": "McCabe (1976)"
    }
  },

  "optimizationGoals": {
    "description": "Architecture optimization targets",
    "goals": {
      "allocationCoherence": {
        "name": "Allokations-Kohärenz",
        "rule": "Je höher die Übereinstimmung Funktion ↔ Modul, desto besser",
        "rationale": "Reduziert Cross-Cutting, vereinfacht Test und Wartung",
        "metric": "allocationCohesion >= 0.8"
      },
      "minimizeCoupling": {
        "name": "Kopplung minimieren",
        "rule": "Je weniger funktionale Verbindungen zwischen Funktionen, desto besser",
        "rationale": "Loose Coupling, unabhängige Entwicklung",
        "metric": "fanOut <= 7"
      },
      "interfaceHomogeneity": {
        "name": "Schnittstellen-Homogenität",
        "rule": "Je weniger unterschiedliche Verbindungsformate, desto besser",
        "rationale": "Reduziert Integrationsaufwand",
        "metric": "Minimize unique SCHEMA types per system"
      }
    },
    "tradeoffs": {
      "interfaceComplexity": {
        "description": "Schnittstellen-Komplexität Trade-off",
        "optionA": {
          "name": "Wenige Verbindungen, komplexe Daten",
          "result": "Einfache Topologie, schwierige Datenverträge"
        },
        "optionB": {
          "name": "Viele Verbindungen, einfache Daten",
          "result": "Komplexe Topologie, triviale Datenverträge"
        },
        "faustregel": "Minimiere das Produkt aus Anzahl Verbindungen × Datenformat-Varianten"
      }
    },
    "principles": [
      "High Fan-in, Low Fan-out ist das Ideal (Card & Glass 1990, Basili et al. 1996)",
      "Kohäsion und Kopplung korrelieren: hohe Kohäsion → loose Coupling (Constantine & Yourdon 1979)",
      "INCOSE gibt keine konkreten Schwellwerte vor – bewusst domänenunabhängig"
    ],
    "calibration": [
      "Eigene Systemdaten analysieren (z.B. Neo4j-Graph-Metriken)",
      "Korrelation mit Integrationsproblemen suchen",
      "Eigene Schwellwerte aus Erfahrung ableiten"
    ]
  },

  "decisionTrees": {
    "nestingVsSubsystem": {
      "question": "Muss ich die internen Zusammenhänge spezifizieren?",
      "yes": "Nested Functions (volle Gestaltungshoheit, interne Wirkketten modellieren)",
      "no": "Subsystem (Black Box, nur Integration, externe Schnittstellen)",
      "criteriaForNesting": [
        "Du baust/spezifizierst die Interna",
        "Du definierst interne Datenflüsse",
        "Du musst reinzoomen um zu spezifizieren"
      ],
      "criteriaForSubsystem": [
        "Zugekauft, fremdes Team, existierendes System",
        "Nur Aggregation der Außenschnittstellen",
        "Keine Einsicht/Kontrolle über Interna nötig"
      ],
      "faustregel": "Subsystem lohnt sich, wenn die Schnittstelle einfacher ist als die Interna"
    },
    "subsystemCriteria": {
      "question": "Lohnt sich ein separates Subsystem?",
      "triggers": [
        "Eigenständig spezifizierbar/testbar",
        "Wenige externe, viele interne Verbindungen",
        "Anderer Lieferant/Team",
        "Andere Technologiedomäne",
        "Anderer Lebenszyklus"
      ],
      "rule": "Any 1+ trigger = consider Subsystem",
      "result": {
        "allNo": "Nested Functions ausreichend",
        "anyYes": "SUBSYSTEM empfohlen"
      }
    },
    "actorVsSubsystem": {
      "question": "Actor oder Subsystem?",
      "distinction": "Kernunterscheidung nach Perspektive",
      "fromInside": {
        "perspective": "Von innen nach außen",
        "view": "Systemgrenze",
        "element": "Actor",
        "meaning": "Was mein System sieht – Schnittstelle, kein Einblick"
      },
      "fromAbove": {
        "perspective": "Von oben nach unten",
        "view": "SoS-Dekomposition",
        "element": "Subsystem",
        "meaning": "Was das Muttersystem sieht – integrierbarer Baustein"
      },
      "rule": "Ein Subsystem wird zum Actor, sobald du es von einem Nachbarsystem aus betrachtest"
    },
    "allocationOptimization": {
      "question": "Funktion verteilt auf mehrere Module?",
      "yes": {
        "followUp": "Lässt sich Funktion splitten?",
        "ifYes": "Splitten, sauber allokieren",
        "ifNo": "Cross-Cutting akzeptieren, Schnittstelle definieren"
      },
      "no": "Optimal - keine Aktion nötig"
    },
    "moduleCohesion": {
      "question": "Modul enthält viele unzusammenhängende Funktionen?",
      "yes": "Prüfen: Modul aufteilen oder Funktionen umgruppieren",
      "no": "Optimal - keine Aktion nötig",
      "indicators": {
        "lowCohesion": "LCOM4 > 1 (mehrere Verantwortlichkeiten)",
        "highFanOut": "Fan-out > 7 (zu viele Abhängigkeiten)"
      }
    },
    "volatilityClassification": {
      "question": "What is the expected rate of change for this FUNC?",
      "description": "Determine volatility level to enforce Design for Change principle",
      "criteria": {
        "high": [
          "Depends on external APIs (social media, payment, weather, etc.)",
          "Uses AI/ML models (prompts, inference, embeddings)",
          "Integrates with third-party systems",
          "Subject to frequent regulatory changes",
          "User-configurable behavior"
        ],
        "medium": [
          "Internal transformation/calculation",
          "Business rules with occasional updates",
          "Internal service communication"
        ],
        "low": [
          "Core business logic with stable rules",
          "Data persistence/retrieval (database operations)",
          "Stable algorithms (sorting, validation, formatting)",
          "Infrastructure utilities (logging, monitoring)"
        ]
      },
      "architecturalGuidance": {
        "high": "Isolate behind stable interface (Adapter/Facade). Max 2 dependents.",
        "medium": "Standard coupling rules apply. Fan-out ≤7.",
        "low": "Can be widely used. High fan-in acceptable."
      }
    }
  },

  "semanticIdFormat": {
    "pattern": "{NodeName}.{TypeAbbr}.{Counter}",
    "example": "ValidateOrder.FN.001",
    "constraints": {
      "nodeName": "PascalCase, max 25 chars, no spaces",
      "typeAbbr": "2-char abbreviation from nodeTypes",
      "counter": "3 digits, zero-padded"
    }
  },

  "rewardCalculation": {
    "description": "Aggregate reward from validation rule compliance for AgentDB episodes",
    "formula": "reward_total = w1 * reward_ontology + w2 * req_quality_score + w3 * uc_quality_score + w4 * func_distinctness_score",
    "hardRuleFailure": "If any hard rule fails, reward_ontology = 0.0",
    "successThreshold": 0.7,
    "componentWeights": {
      "reward_ontology": 0.40,
      "req_quality_score": 0.25,
      "uc_quality_score": 0.15,
      "func_distinctness_score": 0.20
    },
    "structuralRuleWeights": {
      "function_requirements": 0.20,
      "function_io": 0.15,
      "flow_connectivity": 0.15,
      "function_allocation": 0.15,
      "millers_law": 0.10,
      "requirements_verification": 0.10,
      "fchain_actor_boundary": 0.10,
      "volatile_func_isolation": 0.10,
      "func_merge_candidate": 0.10,
      "func_description_quality": 0.05,
      "isolation": 0.05,
      "flow_data_schema": 0.05,
      "schema_struct_property": 0.05
    },
    "reqQualityWeights": {
      "req_verifiable": 0.25,
      "req_necessary": 0.20,
      "req_singular": 0.15,
      "req_unambiguous": 0.15,
      "req_conforming": 0.15,
      "req_complete": 0.10
    },
    "ucQualityWeights": {
      "uc_has_requirements": 0.25,
      "uc_has_actor": 0.25,
      "uc_has_scenario": 0.20,
      "uc_goal_defined": 0.15,
      "uc_postcondition": 0.10,
      "uc_precondition": 0.05
    },
    "funcDistinctnessFormula": "1.0 - (merge_candidate_pairs / total_func_pairs)",
    "phaseThresholds": {
      "phase1to2": {
        "req_quality_score": 0.7,
        "uc_quality_score": 0.7
      },
      "phase2to3": {
        "reward_ontology": 0.7,
        "func_distinctness_score": 0.8
      },
      "phase3to4": {
        "reward_ontology": 0.7
      },
      "phase4toHandoff": {
        "reward_total": 0.7
      }
    }
  },

  "llmContext": {
    "systemPromptSection": "You are working with a Systems Engineering ontology based on INCOSE/SysML 2.0. Key rules: (1) Functional view is primary - FUNC nodes for behavior, (2) Physical view is secondary - MOD nodes for realization, (3) Miller's Law: 5-9 top-level blocks, (4) Every FUNC needs satisfy→REQ and io↔FLOW, (5) Every REQ needs verify→TEST, (6) No near-duplicate FUNCs (similarity ≥0.85).",
    "critiqueTemplate": "Validation failed:\n{violations}\n\nTo fix: {suggestions}",
    "suggestionMap": {
      "function_requirements": "Add satisfy→REQ edge to link function to requirement",
      "function_io": "Add io↔FLOW edges for input and output data flows",
      "function_allocation": "Add allocate edge from MOD to this FUNC",
      "requirements_verification": "Add verify→TEST edge to link requirement to test case",
      "flow_connectivity": "Ensure FLOW has both incoming and outgoing io edges",
      "naming": "Rename to PascalCase, max 25 characters",
      "nested_func_isolation": "Nested functions can only connect within their parent whitebox or to parent-level FLOWs. Route cross-whitebox communication through top-level FUNC boundaries.",
      "volatile_func_isolation": "High-volatility FUNC has too many dependents. Wrap behind stable interface (Adapter/Facade pattern) to isolate change impact.",
      "func_near_duplicate": "Near-duplicate FUNCs detected. Merge into single abstract function or differentiate clearly.",
      "func_merge_candidate": "Similar FUNCs detected. Consider merging or creating common abstraction.",
      "no_duplicate_nodes": "Duplicate node detected. Each (type, name, parent) combination must be unique.",
      "no_duplicate_edges": "Duplicate edge detected. Each (source, target, edgeType) combination must be unique.",
      "no_self_loops": "Self-referencing edge detected. An edge cannot have the same source and target node."
    }
  },

  "whiteboxRules": {
    "description": "Rules for nested function decomposition (whitebox view)",
    "nestedFuncCommunication": {
      "allowed": [
        "Nested FUNC ↔ Nested FUNC (same parent whitebox)",
        "Nested FUNC ↔ Parent-level FLOW (boundary interface)"
      ],
      "forbidden": [
        "Nested FUNC (Parent A) ↔ Nested FUNC (Parent B) directly"
      ],
      "rationale": "Maintains encapsulation. Cross-whitebox communication must go through parent-level interfaces to preserve modularity."
    },
    "example": {
      "valid": [
        "TopLevelA -compose-> NestedA1 -io-> InternalFlowA -io-> NestedA2",
        "TopLevelA -compose-> NestedA1 -io-> BoundaryFlowAB (at TopLevelA boundary)",
        "BoundaryFlowAB -io-> TopLevelB"
      ],
      "invalid": [
        "TopLevelA -compose-> NestedA1 -io-> DirectFlow -io-> NestedB1 <-compose- TopLevelB"
      ]
    }
  }
}
