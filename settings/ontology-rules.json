{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "id": "graphengine-ontology-rules",
  "version": "3.0.7",
  "description": "Consolidated ontology: node/edge types, validation rules, decision trees, optimization goals. Single source of truth for LLM context and self-learning reward calculation.",

  "meta": {
    "sources": [
      "docs/System Decomposition Rules.md",
      "docs/AGENTEN-BASIERTES SYSTEMS ENGINEERING.md",
      "settings/ontology.json",
      "docs/ontology_schema.json"
    ],
    "standards": ["INCOSE SE Handbook v5", "ISO/IEC/IEEE 15288:2023", "A-SPICE", "SysML 2.0"],
    "created": "2025-11-27",
    "author": "andreas@siglochconsulting"
  },

  "nodeTypes": {
    "SYS": {
      "name": "System",
      "description": "Top-level system boundary. Root of all decomposition.",
      "abbreviation": "SY",
      "requiredProperties": ["uuid", "type", "Name", "Descr"],
      "propertyConstraints": {
        "Name": { "type": "string", "maxLength": 25, "pattern": "^[A-Z][a-zA-Z0-9]*$" },
        "Descr": { "type": "string" }
      },
      "allowedOutgoingEdges": ["compose"],
      "allowedTargets": { "compose": ["UC", "MOD", "FUNC", "SYS"] },
      "notes": "SYS→SYS only for external/purchased subsystems. Use FUNC→FUNC for logical decomposition."
    },
    "UC": {
      "name": "Use Case",
      "description": "User-facing functionality. Außensicht: was wird gefordert.",
      "abbreviation": "UC",
      "requiredProperties": ["uuid", "type", "Name", "Descr"],
      "propertyConstraints": {
        "Name": { "type": "string", "maxLength": 25, "pattern": "^[A-Z][a-zA-Z0-9]*$" },
        "Descr": { "type": "string" }
      },
      "allowedOutgoingEdges": ["compose", "satisfy"],
      "allowedTargets": { "compose": ["UC", "FCHAIN"], "satisfy": ["REQ"] }
    },
    "REQ": {
      "name": "Requirement",
      "description": "Functional or non-functional requirement.",
      "abbreviation": "RQ",
      "requiredProperties": ["uuid", "type", "Name", "Descr"],
      "propertyConstraints": {
        "Name": { "type": "string", "maxLength": 25, "pattern": "^[A-Z][a-zA-Z0-9]*$" },
        "Descr": { "type": "string" }
      },
      "allowedOutgoingEdges": ["satisfy", "verify"],
      "allowedTargets": { "satisfy": ["REQ"], "verify": ["TEST"] }
    },
    "FUNC": {
      "name": "Function",
      "description": "Specific capability or processing step. Innensicht: Verhalten, Transformation.",
      "abbreviation": "FN",
      "requiredProperties": ["uuid", "type", "Name", "Descr"],
      "propertyConstraints": {
        "Name": { "type": "string", "maxLength": 25, "pattern": "^[A-Z][a-zA-Z0-9]*$" },
        "Descr": { "type": "string" }
      },
      "allowedOutgoingEdges": ["compose", "satisfy", "io"],
      "allowedTargets": { "compose": ["FUNC"], "satisfy": ["REQ"], "io": ["FLOW"] }
    },
    "FCHAIN": {
      "name": "Function Chain",
      "description": "Sequence of functions implementing a use case. Activity diagram.",
      "abbreviation": "FC",
      "requiredProperties": ["uuid", "type", "Name", "Descr"],
      "propertyConstraints": {
        "Name": { "type": "string", "maxLength": 25, "pattern": "^[A-Z][a-zA-Z0-9]*$" },
        "Descr": { "type": "string" }
      },
      "allowedOutgoingEdges": ["compose"],
      "allowedTargets": { "compose": ["ACTOR", "FUNC", "FLOW"] }
    },
    "FLOW": {
      "name": "Data Flow",
      "description": "3-Layer interface: Layer 1 (Semantik) in Descr, Layer 2 (Datenformat) via relation to SCHEMA, Layer 3 (Protokoll) via relation to SCHEMA.",
      "abbreviation": "FL",
      "requiredProperties": ["uuid", "type", "Name", "Descr"],
      "propertyConstraints": {
        "Name": { "type": "string", "maxLength": 25, "pattern": "^[A-Z][a-zA-Z0-9]*$" },
        "Descr": { "type": "string" }
      },
      "allowedOutgoingEdges": ["io", "relation"],
      "allowedTargets": { "io": ["FUNC", "ACTOR"], "relation": ["SCHEMA"] },
      "requiredRelations": ["relation→SCHEMA (DataSchema)"],
      "optionalRelations": ["relation→SCHEMA (ProtocolSchema)"]
    },
    "ACTOR": {
      "name": "Actor",
      "description": "External entity. Alles außerhalb deiner Spezifikationshoheit.",
      "abbreviation": "AC",
      "requiredProperties": ["uuid", "type", "Name", "Descr"],
      "propertyConstraints": {
        "Name": { "type": "string", "maxLength": 25, "pattern": "^[A-Z][a-zA-Z0-9]*$" },
        "Descr": { "type": "string" }
      },
      "allowedOutgoingEdges": ["io"],
      "allowedTargets": { "io": ["FLOW"] },
      "subtypes": ["SisterSystem", "ExternalSystem", "HumanActor"]
    },
    "MOD": {
      "name": "Module",
      "description": "Physical or software component. Physische Realisierung.",
      "abbreviation": "MD",
      "requiredProperties": ["uuid", "type", "Name", "Descr"],
      "propertyConstraints": {
        "Name": { "type": "string", "maxLength": 25, "pattern": "^[A-Z][a-zA-Z0-9]*$" },
        "Descr": { "type": "string" }
      },
      "allowedOutgoingEdges": ["compose", "allocate"],
      "allowedTargets": { "compose": ["MOD"], "allocate": ["FUNC"] }
    },
    "TEST": {
      "name": "Test Case",
      "description": "Verification test case.",
      "abbreviation": "TC",
      "requiredProperties": ["uuid", "type", "Name", "Descr"],
      "propertyConstraints": {
        "Name": { "type": "string", "maxLength": 25, "pattern": "^[A-Z][a-zA-Z0-9]*$" },
        "Descr": { "type": "string" }
      },
      "allowedOutgoingEdges": ["verify"],
      "allowedTargets": { "verify": ["TEST"] }
    },
    "SCHEMA": {
      "name": "Schema",
      "description": "Global definition. Categories: DataSchema, ProtocolSchema, TypeSchema.",
      "abbreviation": "SC",
      "requiredProperties": ["uuid", "type", "Name", "Descr", "Struct"],
      "propertyConstraints": {
        "Name": { "type": "string", "maxLength": 25, "pattern": "^[A-Z][a-zA-Z0-9]*$" },
        "Descr": { "type": "string" },
        "Struct": { "type": "string", "format": "json" }
      },
      "allowedOutgoingEdges": ["relation"],
      "allowedTargets": { "relation": ["FUNC", "FLOW"] },
      "categories": {
        "DataSchema": "Data structure/format (SysML Interface Block)",
        "ProtocolSchema": "Transport behavior (SysML Flow Specification)",
        "TypeSchema": "Shared type definitions (SysML Value Type)"
      }
    }
  },

  "edgeTypes": {
    "compose": {
      "name": "Composition",
      "description": "Hierarchical parent-child nesting",
      "isNesting": true,
      "validConnections": [
        ["SYS", "SYS"], ["SYS", "UC"], ["SYS", "MOD"], ["SYS", "FUNC"],
        ["UC", "UC"], ["UC", "FCHAIN"],
        ["FCHAIN", "ACTOR"], ["FCHAIN", "FUNC"], ["FCHAIN", "FLOW"],
        ["MOD", "MOD"], ["FUNC", "FUNC"]
      ]
    },
    "io": {
      "name": "Data Flow",
      "description": "Input/Output connection via FLOW nodes",
      "isNesting": false,
      "isChain": true,
      "validConnections": [
        ["FUNC", "FLOW"], ["FLOW", "FUNC"],
        ["ACTOR", "FLOW"], ["FLOW", "ACTOR"]
      ]
    },
    "satisfy": {
      "name": "Satisfaction",
      "description": "Requirement satisfaction traceability",
      "isNesting": true,
      "validConnections": [
        ["SYS", "REQ"], ["REQ", "REQ"], ["UC", "REQ"], ["FUNC", "REQ"]
      ]
    },
    "verify": {
      "name": "Verification",
      "description": "Test verification of requirements",
      "isNesting": false,
      "validConnections": [
        ["TEST", "TEST"], ["REQ", "TEST"]
      ]
    },
    "allocate": {
      "name": "Allocation",
      "description": "Function allocation to module",
      "isNesting": true,
      "validConnections": [
        ["MOD", "FUNC"]
      ]
    },
    "relation": {
      "name": "Relation",
      "description": "Generic relationship (FLOW→SCHEMA for interface contracts)",
      "isNesting": false,
      "validConnections": [
        ["FLOW", "SCHEMA"], ["SCHEMA", "FUNC"], ["*", "*"]
      ]
    }
  },

  "phases": {
    "phase1_requirements": {
      "name": "System Requirements",
      "description": "Stakeholder Needs → SYS, UC, REQ nodes",
      "deliverables": ["SYS node", "UC hierarchy", "REQ nodes with satisfy edges"],
      "gateRules": ["req_semantic_id", "uc_satisfy_req", "sys_satisfy_nfr"]
    },
    "phase2_logical": {
      "name": "Logical Architecture",
      "description": "Top-Level FUNC blocks, FLOW interfaces, FCHAIN activity diagrams",
      "deliverables": ["5-9 top-level FUNC", "FLOW with SCHEMA", "FCHAIN per leaf UC"],
      "gateRules": ["millers_law_func", "function_requirements", "function_io", "flow_connectivity", "fchain_actor_boundary"]
    },
    "phase3_physical": {
      "name": "Physical Architecture",
      "description": "MOD hierarchy, function allocation",
      "deliverables": ["5-9 top-level MOD", "MOD→FUNC allocation"],
      "gateRules": ["millers_law_mod", "function_allocation", "no_orphan_mod"]
    },
    "phase4_verification": {
      "name": "Integration & Verification",
      "description": "TEST nodes, full traceability",
      "deliverables": ["TEST per REQ", "Full traceability path"],
      "gateRules": ["requirements_verification", "isolation", "naming", "full_traceability"]
    }
  },

  "validationRules": {
    "naming": {
      "id": "naming",
      "description": "All names PascalCase, max 25 characters",
      "phase": "all",
      "severity": "error",
      "weight": 0.05,
      "cypher": "MATCH (n) WHERE n.Name IS NOT NULL AND (NOT n.Name =~ '^[A-Z][a-zA-Z0-9]{0,24}$') RETURN n.semanticId AS violation, 'Invalid name format' AS reason"
    },
    "required_properties": {
      "id": "required_properties",
      "description": "All nodes must have uuid, type, Name, Descr",
      "phase": "all",
      "severity": "error",
      "weight": 0.10,
      "type": "hard",
      "cypher": "MATCH (n) WHERE n.uuid IS NULL OR n.type IS NULL OR n.Name IS NULL OR n.Descr IS NULL RETURN n.semanticId AS violation, 'Missing required properties' AS reason"
    },
    "isolation": {
      "id": "isolation",
      "description": "All nodes must have at least one edge",
      "phase": "phase4_verification",
      "severity": "warning",
      "weight": 0.05,
      "cypher": "MATCH (n) WHERE NOT (n)--() RETURN n.semanticId AS violation, 'Orphan node' AS reason"
    },
    "millers_law_func": {
      "id": "millers_law_func",
      "description": "5-9 top-level FUNC nodes under SYS (Miller's Law)",
      "phase": "phase2_logical",
      "severity": "warning",
      "weight": 0.10,
      "cypher": "MATCH (s:SYS)-[:compose]->(f:FUNC) WITH s, count(f) AS func_count WHERE func_count < 5 OR func_count > 9 RETURN s.semanticId AS violation, 'FUNC count: ' + func_count + ' (should be 5-9)' AS reason"
    },
    "millers_law_mod": {
      "id": "millers_law_mod",
      "description": "5-9 top-level MOD nodes under SYS (Miller's Law)",
      "phase": "phase3_physical",
      "severity": "warning",
      "weight": 0.10,
      "cypher": "MATCH (s:SYS)-[:compose]->(m:MOD) WITH s, count(m) AS mod_count WHERE mod_count < 5 OR mod_count > 9 RETURN s.semanticId AS violation, 'MOD count: ' + mod_count + ' (should be 5-9)' AS reason"
    },
    "function_requirements": {
      "id": "function_requirements",
      "description": "Every FUNC must satisfy at least one REQ",
      "phase": "phase2_logical",
      "severity": "error",
      "weight": 0.20,
      "cypher": "MATCH (f:FUNC) WHERE NOT (f)-[:satisfy]->(:REQ) RETURN f.semanticId AS violation, 'Missing satisfy→REQ edge' AS reason"
    },
    "function_io": {
      "id": "function_io",
      "description": "Every FUNC must have io input AND output via FLOW",
      "phase": "phase2_logical",
      "severity": "error",
      "weight": 0.15,
      "cypher": "MATCH (f:FUNC) WHERE NOT (:FLOW)-[:io]->(f) OR NOT (f)-[:io]->(:FLOW) RETURN f.semanticId AS violation, 'Missing io input or output' AS reason"
    },
    "flow_connectivity": {
      "id": "flow_connectivity",
      "description": "Every FLOW must have io incoming AND outgoing",
      "phase": "phase2_logical",
      "severity": "error",
      "weight": 0.15,
      "cypher": "MATCH (fl:FLOW) WHERE NOT ()-[:io]->(fl) OR NOT (fl)-[:io]->() RETURN fl.semanticId AS violation, 'Disconnected FLOW' AS reason"
    },
    "fchain_actor_boundary": {
      "id": "fchain_actor_boundary",
      "description": "Every FCHAIN must have ACTOR→...→ACTOR path (at least 2 actors)",
      "phase": "phase2_logical",
      "severity": "warning",
      "weight": 0.10,
      "cypher": "MATCH (fc:FCHAIN)-[:compose]->(a:ACTOR) WITH fc, collect(a) AS actors WHERE size(actors) < 2 RETURN fc.semanticId AS violation, 'Missing actor boundary' AS reason"
    },
    "function_allocation": {
      "id": "function_allocation",
      "description": "Every FUNC must be allocated to exactly one MOD",
      "phase": "phase3_physical",
      "severity": "error",
      "weight": 0.15,
      "cypher": "MATCH (f:FUNC) WHERE NOT (:MOD)-[:allocate]->(f) RETURN f.semanticId AS violation, 'Unallocated function' AS reason"
    },
    "requirements_verification": {
      "id": "requirements_verification",
      "description": "Every REQ must be verified by at least one TEST",
      "phase": "phase4_verification",
      "severity": "error",
      "weight": 0.10,
      "cypher": "MATCH (r:REQ) WHERE NOT (r)-[:verify]->(:TEST) RETURN r.semanticId AS violation, 'Unverified requirement' AS reason"
    },
    "flow_data_schema": {
      "id": "flow_data_schema",
      "description": "Every FLOW must have relation to Data SCHEMA (Layer 2)",
      "phase": "phase2_logical",
      "severity": "warning",
      "weight": 0.05,
      "cypher": "MATCH (fl:FLOW) WHERE NOT (fl)-[:relation]->(:SCHEMA) RETURN fl.semanticId AS violation, 'Missing SCHEMA relation' AS reason"
    },
    "schema_struct_property": {
      "id": "schema_struct_property",
      "description": "Every SCHEMA must have Struct property with JSON",
      "phase": "all",
      "severity": "error",
      "weight": 0.05,
      "cypher": "MATCH (s:SCHEMA) WHERE s.Struct IS NULL OR s.Struct = '' RETURN s.semanticId AS violation, 'Missing Struct property' AS reason"
    },
    "uc_satisfy_req": {
      "id": "uc_satisfy_req",
      "description": "Every functional REQ should have UC→satisfy→REQ",
      "phase": "phase1_requirements",
      "severity": "warning",
      "weight": 0.05,
      "cypher": "MATCH (r:REQ) WHERE NOT (:UC)-[:satisfy]->(r) AND NOT (:SYS)-[:satisfy]->(r) RETURN r.semanticId AS violation, 'REQ not linked to UC or SYS' AS reason"
    },
    "nested_func_isolation": {
      "id": "nested_func_isolation",
      "description": "Nested FUNCs may ONLY connect to: (1) other nested FUNCs within same parent (whitebox), (2) parent-level FLOWs (IN/OUT of top-level FUNC). Direct connections between nested FUNCs of different whiteboxes are FORBIDDEN.",
      "phase": "phase2_logical",
      "severity": "error",
      "weight": 0.15,
      "type": "hard",
      "cypher": "MATCH (parent1:FUNC)-[:compose]->(nested1:FUNC)-[:io]->(:FLOW)-[:io]->(nested2:FUNC)<-[:compose]-(parent2:FUNC) WHERE parent1 <> parent2 RETURN nested1.semanticId + ' → ' + nested2.semanticId AS violation, 'Cross-whitebox connection between nested functions' AS reason",
      "allowedPatterns": [
        "NestedFunc -io-> InternalFlow -io-> NestedFunc (same parent)",
        "NestedFunc -io-> ParentLevelFlow (exposed at parent boundary)"
      ],
      "forbiddenPatterns": [
        "NestedFunc(ParentA) -io-> Flow -io-> NestedFunc(ParentB)"
      ]
    }
  },

  "qualityIndicators": {
    "fanOut": {
      "description": "Outgoing edges per node",
      "threshold": 7,
      "source": "McConnell, Code Complete (2004)",
      "cypher": "MATCH (n)-[r]->() WITH n, count(r) AS fanOut WHERE fanOut > 7 RETURN n.semanticId, fanOut"
    },
    "instability": {
      "description": "I = Fan-out / (Fan-in + Fan-out), closer to 0 = more stable",
      "thresholdMax": 0.5,
      "source": "Fenton & Melton",
      "formula": "I = Fan-out / (Fan-in + Fan-out)"
    },
    "allocationCohesion": {
      "description": "Ratio of FUNC allocated to single MOD vs cross-cutting",
      "thresholdMin": 0.8,
      "source": "INCOSE SE Handbook"
    },
    "lcom4": {
      "description": "Lack of Cohesion of Methods (graph-based)",
      "thresholdOptimal": 1,
      "source": "Chidamber & Kemerer (1994)",
      "meaning": "LCOM4=1 bedeutet eine Verantwortlichkeit"
    },
    "cyclomaticComplexity": {
      "description": "Control flow complexity",
      "threshold": 10,
      "source": "McCabe (1976)"
    }
  },

  "optimizationGoals": {
    "description": "Architecture optimization targets",
    "goals": {
      "allocationCoherence": {
        "name": "Allokations-Kohärenz",
        "rule": "Je höher die Übereinstimmung Funktion ↔ Modul, desto besser",
        "rationale": "Reduziert Cross-Cutting, vereinfacht Test und Wartung",
        "metric": "allocationCohesion >= 0.8"
      },
      "minimizeCoupling": {
        "name": "Kopplung minimieren",
        "rule": "Je weniger funktionale Verbindungen zwischen Funktionen, desto besser",
        "rationale": "Loose Coupling, unabhängige Entwicklung",
        "metric": "fanOut <= 7"
      },
      "interfaceHomogeneity": {
        "name": "Schnittstellen-Homogenität",
        "rule": "Je weniger unterschiedliche Verbindungsformate, desto besser",
        "rationale": "Reduziert Integrationsaufwand",
        "metric": "Minimize unique SCHEMA types per system"
      }
    },
    "tradeoffs": {
      "interfaceComplexity": {
        "description": "Schnittstellen-Komplexität Trade-off",
        "optionA": {
          "name": "Wenige Verbindungen, komplexe Daten",
          "result": "Einfache Topologie, schwierige Datenverträge"
        },
        "optionB": {
          "name": "Viele Verbindungen, einfache Daten",
          "result": "Komplexe Topologie, triviale Datenverträge"
        },
        "faustregel": "Minimiere das Produkt aus Anzahl Verbindungen × Datenformat-Varianten"
      }
    },
    "principles": [
      "High Fan-in, Low Fan-out ist das Ideal (Card & Glass 1990, Basili et al. 1996)",
      "Kohäsion und Kopplung korrelieren: hohe Kohäsion → loose Coupling (Constantine & Yourdon 1979)",
      "INCOSE gibt keine konkreten Schwellwerte vor – bewusst domänenunabhängig"
    ],
    "calibration": [
      "Eigene Systemdaten analysieren (z.B. Neo4j-Graph-Metriken)",
      "Korrelation mit Integrationsproblemen suchen",
      "Eigene Schwellwerte aus Erfahrung ableiten"
    ]
  },

  "decisionTrees": {
    "nestingVsSubsystem": {
      "question": "Muss ich die internen Zusammenhänge spezifizieren?",
      "yes": "Nested Functions (volle Gestaltungshoheit, interne Wirkketten modellieren)",
      "no": "Subsystem (Black Box, nur Integration, externe Schnittstellen)",
      "criteriaForNesting": [
        "Du baust/spezifizierst die Interna",
        "Du definierst interne Datenflüsse",
        "Du musst reinzoomen um zu spezifizieren"
      ],
      "criteriaForSubsystem": [
        "Zugekauft, fremdes Team, existierendes System",
        "Nur Aggregation der Außenschnittstellen",
        "Keine Einsicht/Kontrolle über Interna nötig"
      ],
      "faustregel": "Subsystem lohnt sich, wenn die Schnittstelle einfacher ist als die Interna"
    },
    "subsystemCriteria": {
      "question": "Lohnt sich ein separates Subsystem?",
      "triggers": [
        "Eigenständig spezifizierbar/testbar",
        "Wenige externe, viele interne Verbindungen",
        "Anderer Lieferant/Team",
        "Andere Technologiedomäne",
        "Anderer Lebenszyklus"
      ],
      "rule": "Any 1+ trigger = consider Subsystem",
      "result": {
        "allNo": "Nested Functions ausreichend",
        "anyYes": "SUBSYSTEM empfohlen"
      }
    },
    "actorVsSubsystem": {
      "question": "Actor oder Subsystem?",
      "distinction": "Kernunterscheidung nach Perspektive",
      "fromInside": {
        "perspective": "Von innen nach außen",
        "view": "Systemgrenze",
        "element": "Actor",
        "meaning": "Was mein System sieht – Schnittstelle, kein Einblick"
      },
      "fromAbove": {
        "perspective": "Von oben nach unten",
        "view": "SoS-Dekomposition",
        "element": "Subsystem",
        "meaning": "Was das Muttersystem sieht – integrierbarer Baustein"
      },
      "rule": "Ein Subsystem wird zum Actor, sobald du es von einem Nachbarsystem aus betrachtest"
    },
    "allocationOptimization": {
      "question": "Funktion verteilt auf mehrere Module?",
      "yes": {
        "followUp": "Lässt sich Funktion splitten?",
        "ifYes": "Splitten, sauber allokieren",
        "ifNo": "Cross-Cutting akzeptieren, Schnittstelle definieren"
      },
      "no": "Optimal - keine Aktion nötig"
    },
    "moduleCohesion": {
      "question": "Modul enthält viele unzusammenhängende Funktionen?",
      "yes": "Prüfen: Modul aufteilen oder Funktionen umgruppieren",
      "no": "Optimal - keine Aktion nötig",
      "indicators": {
        "lowCohesion": "LCOM4 > 1 (mehrere Verantwortlichkeiten)",
        "highFanOut": "Fan-out > 7 (zu viele Abhängigkeiten)"
      }
    }
  },

  "semanticIdFormat": {
    "pattern": "{NodeName}.{TypeAbbr}.{Counter}",
    "example": "ValidateOrder.FN.001",
    "constraints": {
      "nodeName": "PascalCase, max 25 chars, no spaces",
      "typeAbbr": "2-char abbreviation from nodeTypes",
      "counter": "3 digits, zero-padded"
    }
  },

  "rewardCalculation": {
    "description": "Aggregate reward from validation rule compliance for AgentDB episodes",
    "formula": "reward = 1.0 - sum(weight * violation_count / total_nodes)",
    "hardRuleFailure": "If any hard rule fails, reward = 0.0",
    "successThreshold": 0.7,
    "weights": {
      "required_properties": 0.10,
      "naming": 0.05,
      "function_requirements": 0.20,
      "function_io": 0.15,
      "flow_connectivity": 0.15,
      "function_allocation": 0.15,
      "millers_law_func": 0.10,
      "millers_law_mod": 0.10,
      "requirements_verification": 0.10,
      "isolation": 0.05,
      "fchain_actor_boundary": 0.10,
      "flow_data_schema": 0.05,
      "schema_struct_property": 0.05,
      "nested_func_isolation": 0.15
    }
  },

  "llmContext": {
    "systemPromptSection": "You are working with a Systems Engineering ontology based on INCOSE/SysML 2.0. Key rules: (1) Functional view is primary - FUNC nodes for behavior, (2) Physical view is secondary - MOD nodes for realization, (3) Miller's Law: 5-9 top-level blocks, (4) Every FUNC needs satisfy→REQ and io↔FLOW, (5) Every REQ needs verify→TEST.",
    "critiqueTemplate": "Validation failed:\n{violations}\n\nTo fix: {suggestions}",
    "suggestionMap": {
      "function_requirements": "Add satisfy→REQ edge to link function to requirement",
      "function_io": "Add io↔FLOW edges for input and output data flows",
      "function_allocation": "Add allocate edge from MOD to this FUNC",
      "requirements_verification": "Add verify→TEST edge to link requirement to test case",
      "flow_connectivity": "Ensure FLOW has both incoming and outgoing io edges",
      "naming": "Rename to PascalCase, max 25 characters",
      "nested_func_isolation": "Nested functions can only connect within their parent whitebox or to parent-level FLOWs. Route cross-whitebox communication through top-level FUNC boundaries."
    }
  },

  "whiteboxRules": {
    "description": "Rules for nested function decomposition (whitebox view)",
    "nestedFuncCommunication": {
      "allowed": [
        "Nested FUNC ↔ Nested FUNC (same parent whitebox)",
        "Nested FUNC ↔ Parent-level FLOW (boundary interface)"
      ],
      "forbidden": [
        "Nested FUNC (Parent A) ↔ Nested FUNC (Parent B) directly"
      ],
      "rationale": "Maintains encapsulation. Cross-whitebox communication must go through parent-level interfaces to preserve modularity."
    },
    "example": {
      "valid": [
        "TopLevelA -compose-> NestedA1 -io-> InternalFlowA -io-> NestedA2",
        "TopLevelA -compose-> NestedA1 -io-> BoundaryFlowAB (at TopLevelA boundary)",
        "BoundaryFlowAB -io-> TopLevelB"
      ],
      "invalid": [
        "TopLevelA -compose-> NestedA1 -io-> DirectFlow -io-> NestedB1 <-compose- TopLevelB"
      ]
    }
  }
}
